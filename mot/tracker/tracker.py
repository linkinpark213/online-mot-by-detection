import logging
import numpy as np
from typing import List, Dict, Union

from mot.utils import Registry
from mot.encode import Encoder
from mot.detect import Detector
from mot.associate import Matcher
from mot.predict import Predictor
from mot.structures import Tracklet
from mot.structures import Detection, Prediction

__all__ = ['Tracker', 'TRACKER_REGISTRY', 'build_tracker']

TRACKER_REGISTRY = Registry('trackers')


class Tracker:
    def __init__(self, detector: Detector, encoders: List[Encoder], matcher: Matcher, predictor: Predictor = None,
                 max_ttl: int = 30, max_feature_history: int = 30, max_detection_history: int = 3000,
                 min_time_lived: int = 0, keep_finished_tracks: bool = False, **kwargs) -> None:
        self.detector: Detector = detector
        self.encoders: List[Encoder] = encoders
        self.matcher: Matcher = matcher
        self.predictor: Predictor = predictor
        self.max_ttl: int = max_ttl
        self.max_feature_history: int = max_feature_history
        self.max_detection_history: int = max_detection_history
        self.min_time_lived: int = min_time_lived
        self.keep_finished_tracks: bool = keep_finished_tracks
        self.max_id: int = 1
        self.tracklets_active: List[Tracklet] = []
        self.tracklets_finished: List[Tracklet] = []
        self.frame_num: int = 0
        self.logger: logging.Logger = logging.getLogger('MOT')

    def clear(self) -> None:
        self.max_id = 1
        self.tracklets_active = []
        self.tracklets_finished = []
        self.frame_num = 0

    def tick(self, img: np.ndarray):
        """
        Detect, encode and match, following the tracking-by-detection paradigm.
        The tracker works online. For each new frame, the tracker ticks once.

        Args:
            img: A 3D numpy array with shape (H, W, 3). The new frame in the sequence.
        """
        self.frame_num += 1

        # Prediction
        self.predict(img)

        # Detection
        detections = self.detector(img)

        # Encoding
        features = self.encode(detections, img)

        # Data Association
        row_ind, col_ind = self.matcher(self.tracklets_active, features)

        # Log before updating
        self.log(self.tracklets_active, detections, row_ind, col_ind)

        # Tracklet Update
        self.update(row_ind, col_ind, detections, features)

    def encode(self, detections: List[Union[Detection, Prediction]], img: np.ndarray) -> List[Dict]:
        """
        Encode detections using all encoders.

        Args:
            detections: A list of Detection objects.
            img: The image ndarray.

        Returns:
            A list of dicts, with features generated by encoders for each detection.
        """
        features = [{'box': detections[i].box} for i in range(len(detections))]
        for encoder in self.encoders:
            _features = encoder(detections, img)
            for i in range(len(detections)):
                features[i][encoder.name] = _features[i]
        return features

    def predict(self, img: np.ndarray) -> None:
        """
        Predict target positions in the incoming frame.

        Args:
            img: The image ndarray.
        """
        if self.predictor is not None:
            self.predictor(self.tracklets_active, img)

    def update(self, row_ind: List[int], col_ind: List[int], detections: List[Detection],
               detection_features: List[Dict]) -> None:
        """
        Update the tracklets.
        *****************************************************
        Override this function for customized updating policy
        *****************************************************

        Args:
            row_ind: A list of integers. Indices of the matched tracklets.
            col_ind: A list of integers. Indices of the matched detections.
            detections: A list of Detection objects.
            detection_features: The features of the detections.
                By default it's a list of dictionaries, but it can be any form you want.
        """
        # Update tracked tracklets' features
        for i in range(len(row_ind)):
            self.tracklets_active[row_ind[i]].update(self.frame_num, detections[col_ind[i]],
                                                     detection_features[col_ind[i]])

        # Deal with unmatched tracklets
        tracklets_to_kill = []
        unmatched_tracklets = []
        for i in range(len(self.tracklets_active)):
            if i not in row_ind:
                if self.tracklets_active[i].fade():
                    tracklets_to_kill.append(self.tracklets_active[i])
                else:
                    unmatched_tracklets.append(self.tracklets_active[i])

        # Kill tracklets that are unmatched for a while
        for tracklet in tracklets_to_kill:
            self.kill_tracklet(tracklet)

        # Create new tracklets with unmatched detections
        for i in range(len(detection_features)):
            new_tracklets = []
            if i not in col_ind:
                new_tracklet = Tracklet(0, self.frame_num, detections[i], detection_features[i], max_ttl=self.max_ttl,
                                        max_feature_history=self.max_feature_history,
                                        max_detection_history=self.max_detection_history)
                new_tracklets.append(new_tracklet)
                self.add_tracklet(new_tracklet)
            if self.predictor is not None:
                self.predictor.initiate(new_tracklets)

    def terminate(self) -> None:
        """
        Terminate tracking and move all active tracklets to the finished ones.
        """
        for tracklet in self.tracklets_active:
            self.kill_tracklet(tracklet)

    def add_tracklet(self, tracklet: Tracklet) -> None:
        """
        Add a tracklet to the active tracklets after giving it a new ID.

        Args:
            tracklet: The tracklet to be added.
        """
        tracklet.id = self.max_id
        self.max_id += 1
        self.tracklets_active.append(tracklet)

    def kill_tracklet(self, tracklet: Tracklet) -> None:
        self.tracklets_active.remove(tracklet)
        if self.keep_finished_tracks:
            if tracklet.time_lived >= self.min_time_lived:
                self.tracklets_finished.append(tracklet)
        else:
            del tracklet

    def log(self, tracklets: List[Tracklet], detections: List[Detection], row_ind: List[int],
            col_ind: List[int]) -> None:
        # Start with current situation
        self.logger.info(
            'Frame #{}: {} target(s) active, {} object(s) detected'.format(self.frame_num, len(self.tracklets_active),
                                                                           len(detections)))
        # And detections
        if len(detections) > 0:
            self.logger.debug('Detections:')
            for i, detection in enumerate(detections):
                box = detection.box
                self.logger.debug(
                    '\t#{:d}: l = {:.2f}, \tt = {:.2f}, \tr = {:.2f}, \tb = {:.2f}'.format(i, box[0], box[1], box[2],
                                                                                           box[3]))

        # And matches
        if len(row_ind) > 0:
            self.logger.debug('Matches:')
            for i, row in enumerate(row_ind):
                self.logger.debug('\tTracklet #{:d} -- Detection #{:d}'.format(tracklets[row].id, col_ind[i]))

        if len(detections) - len(col_ind) > 0:
            self.logger.debug('New tracklets:')
            count = 0
            for i, col in enumerate(detections):
                if i not in col_ind:
                    self.logger.debug(
                        '\tTracklet #{:d}, from Detection #{:d}'.format(self.max_id + count + 1, i))
                    count += 1


def build_tracker(cfg):
    return TRACKER_REGISTRY.get(cfg.type)(**(cfg.to_dict(ignore_keywords=False)))
